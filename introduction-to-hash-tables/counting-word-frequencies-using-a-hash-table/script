
== PART 1 ==

A hash table is an efficient way to map an identifying value with 
some associated data. We'll call the identifying value a 'key' and the
associated data a 'record'.

For example we could map a name to an address. 

The key would be the name and the record would be the address. 

The advantage of the hash table is that it allows us to quickly look 
up a record based on a key.

There is no need to search through the records in the hash table.

We could also map words to a count of how many times that word appears
in a text.

The key would be the word and the record would be the counter for that word.

In this part of the lecture we'll be discussing an implementation
of a hash tabled called an open addressing hash table.

Lets take a look at how an open addressing hash table works.

    [Action: Begin drawing an array]

At the heart of a hash table is an array. 

Let's say our keys a word made of characters,
specifically a C character string. 

We want to map a word to a location in our hash table.

    [Action: Write the word "apple"]

To determine where in the array to map the key "apple" we'll use a
special function called a hash function. 

The concept is simple.

A key is the input to a hash function and it outputs where in the array
we should store the record for that key. 

The location also known as a bucket.

    [Action: Show an example hash of the word "apple"]

Say we have a hash function called 'h'. 'h' of "apple" might evaluate
to the bucket 3 and we'll store the data for our key there.

    [Action: Show an example hash of the word "orange"]

And 'h' of "orange" might evaluate to bucket 1.

This operation of adding new data to our hash table is named 'insertion'.

You may be wondering what happens if two different keys have the same
hash value, that is, they map to the same bucket? 

There are several techniques for resolving these collisions. 

    [Action: Draw a collision of "apple" and "orange"]

Lets say that "apple" is already inserted into bucket 3. 

Next we try to insert "orange" and it's hash value also maps to bucket 3. 

Ooops! Of course that bucket is already taken.

    [Action: Show a linear prob into bucket 4]

But bucket 4 isn't taken, let's just use that one. 

Thus our strategy is: If a bucket is taken try to insert into the
bucket: bucket +1.

This is where the name "open addressing" comes from. 

If the address of where we want to store our data is already taken, 
we'll just use a different address.

Let's do an example.

    [Action: Show insertion of 'kiwi' into bucket 3]

If 'kiwi' where to evaluate into bucket 3 then, we'll try bucket 3
then bucket 4 then 5.

Since bucket 5 is empty we'll insert 'kiki' there.

If we were to have run out of buckets to try then our hash table is full
and we'll signal some kind of error.

This technique of trying buckets next to each other is called linear probing 
and although it is simple it suffers from a problem called 
'primary clustering'. 

    [Action: Highlight long runs in the hash table]

Notice how long runs of records build up. 

When searching for an item in the hash table it is no longer sufficient to
check only the bucket at h(s) where 's' is some string.

Having to check one or two buckets on average is okay, but as the hash
table fills up, or we are unlucky and get lots of collisions from our
input strings, the advantage of our hash table is lost and we might as
well be using a regular array.

We can avoid these long runs of records with a different hashing strategy
called double hashing.

The hash function for the double hashing strategy takes the form:

    [Action: Write the double hashing function]

    h(s,i) = (h1(s) + i * h2(s)) mod m

Where m is the size of the array we are using for the hash table and
i is the is the current probe attempt starting at i = 0;

    [Action: Draw out example h(s,0), h(s, 1) ]

Now when we insert into our hash table we'll first check the bucket at h(s,0)
then bucket at h(s,1) until we find an empty bucket or we've tried 
all the buckets. 

The double hashing strategy works much better than the linear probing
strategy but we have to make sure that m, the size of the array, and
the value of h2(s,i) meet certain constraints.

m and h2(s,i) must be co-prime. In other words the greatest common factor
of m and h2(s, i) must be 1.

One way to do this is to make sure that m is a power of two and that h2(s,i)
is always odd.

Another important operation is the 'member' operator. 

This operation allows us to test whether some string has already 
been inserted into our hash table. 

    [Action: Testing membership of "apple"]

The concept is similar to insertion. Let's say we want to determine if 
there is a record for the key "apple". Then we'll test the record at h(s,0). 

If we find "apple" then we finished, and the member operator returns true.
If we don't find apple at h(s, 0) then we test h(s, 1), h(s, 2) and so on
until we find an empty bucket or we've tried all the buckets then the
member operator returns false.

In the next part of the lesson we'll go over a sample implementation of the
hash table data structure in the C programming language. See you next time!

== Part 2 ==

In this part of the lecture we'll fire up the text editor and rack up
some keyboard time. We'll be implementing a simple open addressing
hash table.

[Action: Implementing a hash table record]

We'll start by defining how big our hash table is going to be.

[Action: define HASH_TAB]

Next we'll declare the structure that will represent each
record in our hash table. 

The structure, named hashrec which is short for hash record, is composed of
only a character string which we'll use the key. 

However it might be useful to store other data depending on your application.

The record associated with the key could be as simple as a boolean value,
a counter, or another data structure.

We'll try and keep it simple for now.

    [Action: Implementing the hash(), h1(), h2()]

Next we'll define our hash functions. 

Recall that our hashing strategy is going to be double hashing. 

Our hash function will take the form hash(s, i) where s is the character
string we'll be using as the key and i is the current probe attempt starting
at i == 0.

The implementation is simple.

We'll take the value of h1(word) and add it to some multiple of h2(word).

We want to make sure that the resulting hash value doesn't go past the end
of our array so the operation is done modulo HASH_TAB.

    [Action: Implmenent h1]

The h1 hash function take a character string and returns a hash value for
that character string. 

A simple and effective string hash function takes the integer value for
every character of the string and adds it to some multiple of the hash value
so far. 

The value 37 is a prime number that works well.

    [Action: Implement h2]

h2 is a different hash function and it is based on h1 so we can avoid
some code duplication.

Remember that the size of the hash table and h2 must be co-prime. 

Here we've made sure that h2 is always odd and the hash table size is
a power of two.

    [Action: Implement locate]

To help us with both the insertion and member operation we're going to
first implement a helper function named locate.

This helper function takes two arguments a hash table and a character
string key.

The function scans the hash table until either an empty bucket is found, 
the key's record is found, or the entire hash table is scanned without finding
the key's record.

The index of the bucket where any these conditions first 
occurs is returned. 

It will be clear why this is useful when we implement the insertion and
member functions.

    [Action: implement the for loop]

We'll start with a for loops that will allows us to scan every
bucket in the hash table.

We use the hash function to determine the first bucket we'll test.

If the bucket is empty or we have found the key we are looking for
we break out of the loop early and return the index of the bucket.

However if the condition i < HASH_TAB becomes false then we know
we've tried every bucket in that hash table and we return the index
of the last bucket we tested.

    [Action: implement member]


